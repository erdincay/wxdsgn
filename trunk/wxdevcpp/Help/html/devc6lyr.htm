<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Input and Output</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<P><A NAME="topic63"></A><SUP></SUP>Input and Output Functions </P>

<P>Objectives:</P>

<P>Having read this section you should have a clearer idea of one of C's: </P>

<P>1.input functions, called scanf </P>

<P>2.output functions, called printf </P>

<P>On The Run:</P>

<P>Even with arithmetic you can't do very much other than write programs that are the equivalent of a pocket calculator. The real break through comes when you can read values into variables</P>

<P>as the program runs. Notice the important words here: "as the program runs". You can already store values in variables using assignment. That is:</P>

<P>a=100; </P>

<P>stores 100 in the variable a each time you run the program, no matter what you do. Without some sort of input command every program would produce exactly the same result every time it</P>

<P>was run. This would certainly make debugging easy! But in practice, of course, we need programs to do different jobs each time they are run. There are a number of different C input</P>

<P>commands, the most useful of which is the scanf command. To read a single integer value into the variable called a you would use: </P>

<P>scanf("%d",&amp;a); </P>

<P>For the moment don't worry about what the %d or the &gt;&amp;a means - concentrate on the difference between this and: </P>

<P>a=100; </P>

<P>When the program reaches the scanf statement it pauses to give the user time to type something on the keyboard and continues only when users press &lt;Enter&gt;, or &lt;Return&gt;, to signal</P>

<P>that he, or she, has finished entering the value. Then the program continues with the new value stored in a. In this way, each time the program is run the user gets a chance to type in a</P>

<P>different value to the variable and the program also gets the chance to produce a different result! </P>

<P>The final missing piece in the jigsaw is using the printf function, the one we have already used to print "Hello World", to print the value currently being stored in a variable. To display the</P>

<P>value stored in the variable a you would use: </P>

<P>printf("The value stored in a is %d",a); </P>

<P>The %d, both in the case of scanf and printf, simply lets the compiler know that the value being read in, or printed out, is a decimal integer - that is, a few digits but no decimal point. </P>

<P>Note: the scanf function does not prompt for an input. You should get in the habit of always using a printf function, informing the user of the program what they should type, before a</P>

<P>scanf function. </P>

<P>Input and Output Functions in More Detail:</P>

<P>One of the advantages of C is that essentially it is a small language. This means that you can write a complete description of the language in a few pages. It doesn't have many keywords or</P>

<P>data types for that matter. What makes C so powerful is the way that these low-level facilities can be put together to make higher level facilities. </P>

<P>The only problem with this is that C programmers have a tendency to reinvent the wheel each time they want to go for a ride. It is also possible to write C programs in a variety of styles</P>

<P>which depend on the particular tricks and devices that a programmer chooses to use. Even after writing C for a long time you will still find the occasionally construction which makes you</P>

<P>think, "I never thought of that!" or, "what is that doing?" </P>

<P>One attempt to make C a more uniform language is the provision of standard libraries of functions that perform common tasks. We say standard but until the ANSI committee actually</P>

<P>produced a standard there was, and still is, some variation in what the standard libraries contained and exactly how the functions worked. Having said that we had better rush in quickly with</P>

<P>the reassurance that in practice the situation isn't that bad and most of the functions that are used frequently really are standard on all implementations. In particular the I/O functions vary very</P>

<P>little. </P>

<P>It is now time to look at exactly how scanf and printf work and what they can do - you might be surprised at just how complex they really are! </P>

<P>The original C specification did not include commands for input and output. Instead the compiler writers were supposed to implement library functions to suit their machines. In practice all</P>

<P>chose to implement printf and scanf and after a while C programmers started to think of them as if these functions were I/O keywords! It sometimes helps to remember that they are</P>

<P>functions on a par with any other functions you may care to define. If you want to you can provide your own implementations of printf or scanf or any of the other standard functions -</P>

<P>we'll discover how later. </P>

<P>printf:</P>

<P>The printf (and scanf) functions do differ from the sort of functions that you will created for yourself in that they can take a variable number of parameters. In the case of printf the first</P>

<P>parameter is always a string (c.f. "Hello World") but after that you can include as many parameters of any type that you want to. That is, the printf function is usually of the form: </P>

<P>printf(string,variable,variable,variable...) </P>

<P>where the ... means you can carry on writing a list of variables separated by commas as long as you want to. The string is all-important because it specifies the type of each variable in the</P>

<P>list and how you want it printed. The string is usually called the control string or the format string. The way that this works is that printf scans the string from left to right and prints on the</P>

<P>screen, or any suitable output device, any characters it encounters - except when it reaches a % character. The % character is a signal that what follows it is a specification for how the next</P>

<P>variable in the list of variables should be printed. printf uses this information to convert and format the value that was passed to the function by the variable and then moves on to process</P>

<P>the rest of the control string and anymore variables it might specify. For example: </P>

<P>printf("Hello World"); </P>

<P>only has a control string and, as this contains no % characters it results in Hello World being displayed and doesn't need to display any variable values. The specifier %d means convert the</P>

<P>next value to a signed decimal integer and so: </P>

<P>printf("Total = %d",total); </P>

<P>will print Total = and then the value passed by &gt;total as a decimal integer. </P>

<P>If you are familiar other programming languages then you may feel happy about the printf function because something like:</P>

<P>printf("Total = %d",total);</P>

<P>looks like the sort of output command you might have used before. For example, in BASIC you would write: </P>

<P>PRINT "Total = ",total </P>

<P>but the C view of output is at a lower level than you might expect. The %d isn't just a format specifier, it is a conversion specifier. It indicates the data type of the variable to be printed and</P>

<P>how that data type should be converted to the characters that appear on the screen. That is %d says that the next value to be printed is a signed integer value (i.e. a value that would be stored</P>

<P>in a standard int variable) and this should be converted into a sequence of characters (i.e. digits) representing the value in decimal. If by some accident the variable that you are trying to</P>

<P>display happens to be a float or a double then you will still see a value displayed - but it will not correspond to the actual value of the float or double. </P>

<P>The reason for this is twofold. </P>

<P>1.The first difference is that an int uses two bytes to store its value, while a float uses four and a double uses eight. If you try to display a float or a double using %d then only the</P>

<P>first two bytes of the value are actually used. </P>

<P>2.The second problem is that even if there wasn't a size difference ints, floats and doubles use a different binary representation and %d expects the bit pattern to be a simple signed</P>

<P>binary integer. </P>

<P>This is all a bit technical, but that's in the nature of C. You can ignore these details as long as you remember two important facts:</P>

<P>1.The specifier following % indicates the type of variable to be displayed as well as the format in which that the value should be displayed; </P>

<P>2.If you use a specifier with the wrong type of variable then you will see some strange things on the screen and the error often propagates to other items in the printf list. </P>

<P>If this seems complicated then I would agree but I should also point out that the benefit is being able to treat what is stored in a variable in a more flexible way than other languages allow.</P>

<P>Other languages never let on to the programmer that what is in fact stored in a variable is a bit pattern, not the decimal value that appears to be stored there when you use a printf (or</P>

<P>whatever) statement. Of course whether you view this as an advantage depends on what you are trying to do. It certainly brings you closer to the way the machine works. </P>

<P>You can also add an 'l' in front of a specifier to mean a long form of the variable type and h to indicate a short form (long and short will be covered later in this course). For example, %ld</P>

<P>means a long integer variable (usually four bytes) and %hd means short int. Notice that there is no distinction between a four-byte float and an eight-byte double. The reason is that a</P>

<P>float is automatically converted to a double precision value when passed to printf - so the two can be treated in the same way. (In pre-ANSI all floats were converted to double</P>

<P>when passed to a function but this is no longer true.) The only real problem that this poses is how to print the value of a pointer? The answer is that you can use %x to see the address in hex</P>

<P>or %o to see the address in octal. Notice that the value printed is the segment offset and not the absolute address - to understand what we am going on about you need to know something</P>

<P>about the structure of your processor. </P>

<P>The % Format Specifiers:</P>

<P>The % specifiers that you can use in ANSI C are: </P>

<P>Usual variable type           Display</P>

<P>%c        char                     single character</P>

<P>%d (%i)   int                      signed integer</P>

<P>%e (%E)   float or double          exponential format</P>

<P>%f        float or double          signed decimal</P>

<P>%g (%G)   float or double          use %f or %e as required</P>

<P>%o        int                      unsigned octal value</P>

<P>%p        pointer                  address stored in pointer</P>

<P>%s        array of char            sequence of characters</P>

<P>%u        int                      unsigned decimal</P>

<P>%x (%X)   int                      unsigned hex value</P>

<P>Formatting Your Output:</P>

<P>The type conversion specifier only does what you ask of it - it convert a given bit pattern into a sequence of characters that a human can read. If you want to format the characters then you</P>

<P>need to know a little more about the printf function's control string. </P>

<P>Each specifier can be preceded by a modifier which determines how the value will be printed. The most general modifier is of the form: </P>

<P>flag width.precision </P>

<P>The flag can be any of:</P>

<P>flag          meaning</P>

<P></P>

<P>-         left justify</P>

<P>+         always display sign</P>

<P>space     display space if there is no sign</P>

<P>0         pad with leading zeros</P>

<P>#         use alternate form of specifier</P>

<P>The width specifies the number of characters used in total to display the value and precision indicates the number of characters used after the decimal point. </P>

<P>For example, %10.3f will display the float using ten characters with three digits after the decimal point. Notice that the ten characters includes the decimal point, and a - sign if there is one.</P>

<P>If the value needs more space than the width specifies then the additional space is used - width specifies the smallest space that will be used to display the value. (This is quiet reassuring,</P>

<P>you won't be the first programmer whose program takes hours to run but the output results can't be viewed because the wrong format width has been specified!) </P>

<P>The specifier %-1Od will display an int left justified in a ten character space. The specifier %+5d will display an int using the next five character locations and will add a + or - sign to the</P>

<P>value. </P>

<P>The only complexity is the use of the # modifier. What this does depends on which type of format it is used with: </P>

<P>%#o    adds a leading 0 to the octal value</P>

<P>%#x    adds a leading 0x to the hex value</P>

<P>%#f or</P>

<P>%#e    ensures decimal point is printed</P>

<P>%#g    displays trailing zeros</P>

<P>Strings will be discussed later but for now remember: if you print a string using the %s specifier then all of the characters stored in the array up to the first null will be printed. If you use a</P>

<P>width specifier then the string will be right justified within the space. If you include a precision specifier then only that number of characters will be printed. </P>

<P>For example: </P>

<P>printf("%s,Hello") </P>

<P>will print Hello, </P>

<P>printf("%25s ,Hello") </P>

<P>will print 25 characters with Hello right justified and </P>

<P>printf("%25.3s,Hello") </P>

<P>will print Hello right justified in a group of 25 spaces. </P>

<P>Also notice that it is fine to pass a constant value to printf as in printf("%s,Hello"). </P>

<P>Finally there are the control codes: </P>

<P>\b       backspace</P>

<P>\f       formfeed</P>

<P>\n       new line</P>

<P>\r       carriage return</P>

<P>\t       horizontal tab</P>

<P>\'       single quote</P>

<P>\0       null</P>

<P>If you include any of these in the control string then the corresponding ASCII control code is sent to the screen, or output device, which should produce the effect listed. In most cases you</P>

<P>only need to remember \n for new line. </P>

<P>scanf:</P>

<P>Now that we have mastered the intricacies of printf you should find scanf very easy. The scanf function works in much the same way as the printf. That is it has the general form: </P>

<P>scanf(control string,variable,variable,...) </P>

<P>In this case the control string specifies how strings of characters, usually typed on the keyboard, should be converted into values and stored in the listed variables. However there are a</P>

<P>number of important differences as well as similarities between scanf and printf. </P>

<P>The most obvious is that scanf has to change the values stored in the parts of computers memory that is associated with parameters (variables). </P>

<P>To understand this fully you will have to wait until we have covered functions in more detail. But, just for now, bare with us when we say to do this the scanf function has to have the</P>

<P>addresses of the variables rather than just their values. This means that simple variables have to be passed with a preceding &gt;&amp;. (Note for future reference: There is no need to do this</P>

<P>for strings stored in arrays because the array name is already a pointer.) </P>

<P>The second difference is that the control string has some extra items to cope with the problems of reading data in. However, all of the conversion specifiers listed in connection with</P>

<P>printf can be used with scanf. </P>

<P>The rule is that scanf processes the control string from left to right and each time it reaches a specifier it tries to interpret what has been typed as a value. If you input multiple values then</P>

<P>these are assumed to be separated by white space - i.e. spaces, newline or tabs. This means you can type: </P>

<P>3 4 5 </P>

<P>or </P>

<P>3</P>

<P>4</P>

<P>5</P>

<P>and it doesn't matter how many spaces are included between items. For example:</P>

<P>scanf("%d %d",&amp;i,&amp;j);</P>

<P>will read in two integer values into i and j. The integer values can be typed on the same line or on different lines as long as there is at least one white space character between them. </P>

<P>The only exception to this rule is the %c specifier which always reads in the next character typed no matter what it is. You can also use a width modifier in scanf. In this case its effect is to</P>

<P>limit the number of characters accepted to the width. </P>

<P>For example: </P>

<P>scanf("%lOd",&amp;i) </P>

<P>would use at most the first ten digits typed as the new value for i. </P>

<P>There is one main problem with scanf function which can make it unreliable in certain cases. The reason being is that scanf tends to ignore white spaces, i.e. the space character. If you</P>

<P>require your input to contain spaces this can cause a problem. Therefore for string data input the function getstr() may well be more reliable as it records spaces in the input text and</P>

<P>treats them as an ordinary characters. </P>

<P>Custom Libraries:</P>

<P>If you think printf and scanf don't seem enough to do the sort of job that any modern programmer expects to do, you would be right. In the early days being able to print a line at a time</P>

<P>was fine but today we expect to be able to print anywhere on the screen at any time. </P>

<P>The point is that as far as standard C goes simple I/O devices are stream-oriented - that is you send or get a stream of characters without any notion of being able to move the current</P>

<P>position in the stream. If you want to move backwards and forwards through the data then you need to use a direct access file. In more simple terms, C doesn't have a Tab(X,Y) or</P>

<P>Locate(X,Y) function or command which moves the cursor to the specified location! How are you ever going to write your latest block buster game, let alone build your sophisticated input</P>

<P>screens? </P>

<P>Well you don't have to worry too much because although C may not define them as standard, all C implementations come with an extensive graphics/text function library that allows you to</P>

<P>do all of this and more. Such a library isn't standard, however the principles are always the same. The Borland and Microsoft offerings are usually considered as the two facto standards. </P>

<P>Summing It Up:</P>

<P>Now that we have arithmetic, a way of reading values in and a way of displaying them, it's possible to write a slightly more interesting program than "Hello World". Not much more</P>

<P>interesting, it's true, but what do you expect with two instructions and some arithmetic? </P>

<P>Let's write a program that adds two numbers together and prints the result. (I told you it wasn't that much more interesting!) Of course, if you want to work out something else like fahrenheit</P>

<P>to centigrade, inches to centimetres or the size of your bank balance, then that's up to you - the principle is the same. </P>

<P>The program is a bit more complicated than you might expect, but only because of the need to let the user know what is happening: </P>

<P>#include &lt;stdio.h&gt;</P>

<P>main()</P>

<P>{</P>

<P>int a,b,c;</P>

<P>printf("\nThe first number is ");</P>

<P>scanf("%d",&amp;a);</P>

<P>printf("The second number is ");</P>

<P>scanf("%d",&amp;b);</P>

<P>c=a+b;</P>

<P>printf("The answer is %d \n",c);</P>

<P>}</P>

<P>The first instruction declares three integer variables: a, b and c. The first two printf statements simply display message on the screen asking the user for the values. The scanf functions</P>

<P>then read in the values from the keyboard into a and b. These are added together and the result in c is displayed on the screen with a suitable message. Notice the way that you can include a</P>

<P>message in the printf statement along with the value. </P>

<P>Type the program in, compile it and link it and the result should be your first interactive program. Try changing it so that it works out something a little more adventurous. Try changing the</P>

<P>messages as well. All you have to remember is that you cannot store values or work out results greater than the range of an integer variable or with a fractional part.</P>

</BODY>
</HTML>
