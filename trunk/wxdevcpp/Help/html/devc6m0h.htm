<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Strings</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<P><A NAME="topic71"></A><SUP></SUP>Objectives</P>

<P>This section brings together the use of two of C's fundamental data types, ponters and arrays, in the use of handling strings. </P>

<P>Having read this section you should be able to: </P>

<P>1.handle any string constant by storing it in an array. </P>

<P>Stringing Along:</P>

<P>Now that we have mastered pointers and the relationship between arrays and pointers we can take a second look at strings. A string is just a character array with the convention that the</P>

<P>end of the valid data is marked by a null '\0'. Now you should be able to see why you can read in a character string using scanf("%s", name) rather than scanf("%s",&amp;name) - name is</P>

<P>already a pointer variable. Manipulating strings is very much a matter of pointers and special string functions. For example, the strlen(str) function returns the number of characters in the</P>

<P>string str. It does this simply by counting the number of characters up to the first null in the character array - so it is important that you are using a valid null-terminated string. Indeed this is</P>

<P>important with all of the C string functions. </P>

<P>You might not think that you need a function to copy strings, but simple assignment between string variables doesn't work. For example: </P>

<P>char a[l0],b[10];</P>

<P>b = a;</P>

<P>does not appear to make a copy of the characters in a, but this is an illusion. What actually happens is that the pointer b is set to point to the same set of characters that a points to, i.e. a</P>

<P>second copy of the string isn't created. </P>

<P>To do this you need strcopy(a,b) which really does make a copy of every character in a in the array b up to the first null character. In a similar fashion strcat(a,b) adds the characters</P>

<P>in b to the end of the string stored in a. Finally there is the all-important strcmp(a,b) which compares the two strings character by character and returns true - that is 0 - if the results are</P>

<P>equal. </P>

<P>Again notice that you can't compare strings using a==b because this just tests to see if the two pointers a and b are pointing to the same memory location. Of course if they are then the two</P>

<P>strings are the same, but it is still possible for two strings to be the same even if they are stored at different locations. </P>

<P>You can see that you need to understand pointers to avoid making simple mistakes using strings. One last problem is how to initialise a character array to a string. You can't use: </P>

<P>a = "hello"; </P>

<P>because a is a pointer and "hello" is a string constant. However, you can use: </P>

<P>strcopy(a,"hello") </P>

<P>because a string constant is passed in exactly the same way as a string variable, i.e. as a pointer. If you are worried where the string constant is stored, the answer is in a special area of</P>

<P>memory along with all of the constants that the program uses. The main disadvantage of this method is that many compilers use an optimisation trick that results in only a single version of</P>

<P>identical constants being stored. For example: </P>

<P>strcopy(b,"hello"); </P>

<P>usually ends up with b pointing to the same string as a. In other words, this method isn't particularly safe! </P>

<P>A much better method is to use array initialisation. You can specify constants to be used to initialise any variable when it is declared. For example: </P>

<P>int a=10; </P>

<P>declares a to be an integer and initialises it to 10. You can initialise an array using a similar notation. For example: </P>

<P>int a[5] = {1,2,3,4,5}; </P>

<P>declares an integer array and initialises it so that a[0]= 1, a[1] = 2 and so on. A character array can be initialised in the same way. For example: </P>

<P>char a[5]={'h','e','l','l','o'}; </P>

<P>but a much better way is to write: </P>

<P>char a[6]="hello"; </P>

<P>which also automatically stores a null character at the end of the string - hence a[6] and not a[5]. If you really want to be lazy you can use: </P>

<P>char a[] = "hello"; </P>

<P>and let the compiler work out how many array elements are needed. Some compilers cannot cope with the idea of initialising a variable that doesn't exist for the entire life of the program. For</P>

<P>those compilers to make initialisation work you need to add the keyword static to the front of the string declaration, therefore: </P>

<P>static char a[] = "hello"; </P>

<P>As easy as... B or C?:</P>

<P>A few words of warning. If you are familiar with BASIC then you will have to treat C strings, and even C arrays, with some caution. They are not as easy or as obvious to use and writing a</P>

<P>program that manipulates text is harder in C than in BASIC. If you try to use C strings as if it were BASIC strings you are sure to create some very weird and wonderful bugs! </P>

<P>A Sort Of Bubble Program:</P>

<P>This sections program implements a simple bubble sort - which is notorious for being one of the worst sorting methods known to programmer-kind, but it does have the advantage of being</P>

<P>easy and instructive. Some of the routines have already been described in the main text and a range of different methods of passing data in functions have also been used. </P>

<P>The main routine is sort which repeats the scan function on the array until the variable done is set to 0. The scan function simply scans down the array comparing elements that are next</P>

<P>door to each other. If they are in the wrong order then function swap is called to swap them over. </P>

<P>Study this program carefully with particular attention to the way arrays, array elements and variables are passed. It is worth saying that in some cases there are better ways of achieving the</P>

<P>same results. In particular, it would have been easier not to use the variable done, but to have returned the state as the result of the scan function. </P>

<P>#include &lt;stdio.h&gt;</P>

<P>void randdat(int a[] , int n);</P>

<P>void sort(int a[] , int n);</P>

<P>void scan(int a[] , int n , int *done);</P>

<P>void swap(int *a ,int *b);</P>

<P>main()</P>

<P>{</P>

<P>int i;</P>

<P>int a[20];</P>

<P>randdat(a , 20);</P>

<P>sort(a , 20);</P>

<P>for(i=0;i&lt;20;++i) printf("%d\n" ,a[i]);</P>

<P>}</P>

<P>void randdat(int a[1] , int n)</P>

<P>{</P>

<P>int i;</P>

<P>for (i=0 ; i&lt;n ; ++i)</P>

<P>a[i] = rand()%n+1;</P>

<P>}</P>

<P>void sort(int a[1] , int n)</P>

<P>{</P>

<P>int done;</P>

<P>done = 1;</P>

<P>while(done == 1) scan(a , n , &amp;done);</P>

<P>}</P>

<P>void scan(int a[1] , int n , int *done)</P>

<P>{</P>

<P>int i;</P>

<P>*done=0;</P>

<P>for(i=0 ; i&lt;n-1 ; ++i)</P>

<P>{</P>

<P>if(a[i]&lt;a[i+1])</P>

<P>{</P>

<P>swap(&amp;a[i],&amp;a[i+1]);</P>

<P>*done=1;</P>

<P>}</P>

<P>}</P>

<P>}</P>

<P>void swap(int *a ,int *b)</P>

<P>{      </P>

<P>int temp;</P>

<P>temp = *a;</P>

<P>*a   = *b;</P>

<P>*b   = temp;</P>

<P>}</P>

</BODY>
</HTML>
